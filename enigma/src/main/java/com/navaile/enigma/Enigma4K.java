/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.navaile.enigma;

import com.zackehh.siphash.*;
import java.text.NumberFormat;
import java.util.*;
import org.apache.log4j.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A next generation Enigma based on the original design.
 * 
 * Software Design
 * The software was designed with laymen in mind. The code is design in
 * such a way as to closely resemble the original mechanical machine.
 *
 * @author navaile
 */
public class Enigma4K {
	
	private static final Logger LOG = LoggerFactory.getLogger(Enigma4K.class);

	/** Directory size.					*/
	public static final int DIR_SIZE = 46_655;				// ZZZ (base36)

	/** Number of rotors in the enigma machine.		*/
	public static final int COUNT_MIN = 97;
	public static final int COUNT_MAX = 46_655;		// ZZZ (base36)
	public static final int RO_COUNT_LOCK = 4_000;
	public static final int PB_COUNT_LOCK = 500;
	
	/** Encryption multiplier.						*/
	public static final int ENCRYPT_MULTI = 97;		// 97
	
	/**
	 * Rotor/Plugboard Permutations
	 * 
	 * perm		= factorial(rotorSize)
	 *			= 46,655!
	 *			= 1.478143766589091023060 x 10^197568
	 *			= 10^10^5.295716976537452
	 */
	
	private static Random RND;
	
	private static Directory directory;

	private static int[][] roMatrix;
	private static int[][] pbMatrix;
	
	/** Rotor Key		*/			private static int[] roKey;
	/** Index for each rotor */		private static int[] roIndex;
	/** Rotor Direction */			private static int[] roDirectionSpin;
	/** Rotor Step Size */			private static int[] roStepSize;
	
	/**
	 * Builds a new enigma machine.
	 * 
	 * @param path file path to word directory
	 * @param passPhrase pass phrase, password
	 * @param handle recipient name/email/handle
	 * @param msgID msgID generated by Enigma4K.genMsgID()
	 * @param roCount rotor count, 97 - 5000
	 * @param pbCount plugboard count, 97 - 500
	 */
	public Enigma4K(String path, String passPhrase, String handle, String msgID, int roCount, int pbCount) {
		
		BasicConfigurator.configure();
//		org.apache.log4j.Logger logger4j = org.apache.log4j.Logger.getRootLogger();
//			logger4j.setLevel(Level.ERROR);
		
		LOG.info("ini AdvEnigma(" + roCount + ", " + pbCount + ")");
		
		directory = Directory.getInstance(path);

		passPhrase = passPhrase + "_" + handle + (msgID != null ? ("_" + msgID) : "");
		LOG.info("passPhrase: " + passPhrase + ", handle: " + handle + ", msgID: " + msgID);

		RND = new Random(hashCode(passPhrase));

		if(roCount < COUNT_MIN)			roCount = COUNT_MIN;
		if(pbCount < COUNT_MIN)			pbCount = COUNT_MIN;
		if(roCount > RO_COUNT_LOCK)		roCount = RO_COUNT_LOCK;	// 4,000
		if(pbCount > PB_COUNT_LOCK)		pbCount = PB_COUNT_LOCK;	// 500 (2 pages)
		
		LOG.info("ini AdvEnigma: genKey, copy to rotorIndex");
		Enigma4K.roKey = genKey(roCount);
		Enigma4K.roIndex = Enigma4K.roKey.clone();
		
		Enigma4K.roDirectionSpin = new int[Enigma4K.roKey.length];
		for(int i = 0; i < Enigma4K.roDirectionSpin.length; i++)
			Enigma4K.roDirectionSpin[i] = (nextBool() ? 1 : -1);
		
		Enigma4K.roStepSize = new int[Enigma4K.roKey.length];
		for(int i = 0; i < Enigma4K.roStepSize.length; i++)
			Enigma4K.roStepSize[i] = nextSeed(31 + 1);
		
		/**
		 * TODO
		 * 
		 */
		
		LOG.info("ini AdvEnigma: generate random rotors/plugboards");

		Enigma4K.roMatrix = new int[roCount][];
		for(int i = 0; i < roMatrix.length; i++)
			roMatrix[i] = genRotorPb(nextSeed());
		
		Enigma4K.pbMatrix = new int[pbCount][];
		for(int i = 0; i < pbMatrix.length; i++)
			pbMatrix[i] = genRotorPb(nextSeed());
		
		memory();
		
		LOG.info("Rotor Count: " + roCount);
		LOG.info("Rotor Key: " + Arrays.toString(roKey));
		LOG.info("Rotor Direction: " + Arrays.toString(Enigma4K.roDirectionSpin));
		LOG.info("Rotor Step Size: " + Arrays.toString(Enigma4K.roStepSize));
		
		LOG.info("Plugboard Count: " + pbCount);
	}
	
	/**
	 * Generate message id.
	 * 
	 * @return 
	 */
	public static String genMsgID() {
		
		StringBuilder time = new StringBuilder();
		Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
			time.append(cal.get(Calendar.SECOND))
				.append(cal.get(Calendar.MINUTE))
				.append(cal.get(Calendar.HOUR_OF_DAY))
				.append(cal.get(Calendar.DAY_OF_YEAR))
				.append(cal.get(Calendar.YEAR));
			
		long msgID = Long.parseLong(time.toString());

		return padText(longToBase36(msgID).toUpperCase(), 9);
	}

	/** Steps/rotates rotor after each word encryption.		*/
	public static void stepRotors(int[] rotorIndex) {

		for(int i = 0; i < rotorIndex.length; i++) {
			
			rotorIndex[i] += roStepSize[i] * roDirectionSpin[i];

			if(rotorIndex[i] >= DIR_SIZE) rotorIndex[i] = rotorIndex[i] % DIR_SIZE;
			else if(rotorIndex[i] < 0) rotorIndex[i] = DIR_SIZE + rotorIndex[i];
		}
		
		LOG.info("stepRotors() new rotor settings: " + Arrays.toString(rotorIndex));
	}
	
	/**
	 * Generates a new rotor key.
	 * 
	 * @return a random key
	 */
	private static int[] genKey(int rotorCount) {
		
		int[] newKey = new int[rotorCount];
		for (int i = 0; i < newKey.length; i++)
			newKey[i] = RND.nextInt(DIR_SIZE);
		
		LOG.info("Generates random rotor key.");
		
		return newKey.clone();
	}
	
	/** Resets rotor key.	*/
	public static void resetKey() {
		Enigma4K.roIndex = Enigma4K.roKey.clone();
		LOG.info("AdvEnigma.resetKey() key: " + Arrays.toString(Enigma4K.roKey));
	}
	
	/**
	 * Encrypt text.
	 * 
	 * @param plainText plaint text to be encrypted
	 * @return crypt text
	 */
	public String encryptText(String plainText) throws Exception {
		
		LOG.error("Enigma4K.encryptText(" + plainText + ")");
		
		StringBuilder log = new StringBuilder();

		String[] wordList = directory.parceWords(plainText.toLowerCase());
		ArrayList<Integer> wordCodeList = new ArrayList<>();
		
		LOG.error("Enigma4K.encryptText().wordList.length: " + wordList.length);
		
		for (String word: wordList) {

			Integer wordCode = directory.getKeyCode(word);
			log.append(word).append(": ").append(wordCode).append("\t");
			
			if(wordCode == null) {
				
				LOG.error("Enigma4K.encryptText word|wordCode: " + word + "|" + wordCode);
				
				char[] letters = word.toCharArray();
				
				LOG.error("Enigma4K.encryptText letter arr: " + Arrays.toString(letters));
				
				wordCodeList.add(directory.getKeyCode("["));
				for(char l: letters) {
					
					Integer keyCode = directory.getKeyCode(String.valueOf(l));
					wordCodeList.add(keyCode);

					if(keyCode == null)
						System.out.println("null keyCode for char: " + Character.getNumericValue(l));
				}
				wordCodeList.add(directory.getKeyCode("]"));
			}
			else {		wordCodeList.add(wordCode);						}
		}
		
		LOG.error(log.toString());
		log = new StringBuilder();
		
		String[] base36List = new String[wordCodeList.size()];
		
		LOG.error("Enigma4K.encryptText.wordCodeList: " + wordCodeList.size());
		LOG.error("Enigma4K.encryptText.wordCodeList.data: " + Arrays.toString(wordCodeList.toArray()));
		
		// wordCodeList check
		LOG.error("wordCodeList: " + Arrays.toString(wordCodeList.toArray()));
		
		for(Integer wordCode: wordCodeList)
			if(wordCode == null)	throw new Exception("Unable to encrypt null.");

		int i = 0;
		for(int wordCode: wordCodeList) {
			
			int pbWordCode = -1, rWordCode = -1;
			for(int m = 0; m < ENCRYPT_MULTI; m++) {
				pbWordCode = pbEncrypt(wordCode, i);
					log.append("pbE:").append(pbWordCode).append("\t");
				rWordCode = rotorEncrypt(pbWordCode);
					log.append("rE:").append(rWordCode).append("\t");
			}
				pbWordCode = pbEncrypt(rWordCode, i);
					log.append("pbE:").append(pbWordCode).append("\t");

			String base36Str = padText(intToBase36(pbWordCode), 3).toUpperCase();
			base36List[i] = base36Str;
				log.append("base36: ").append(base36Str);
				
			i++;
			
			LOG.info(log.toString());
		}
		
		StringBuilder strBuild = new StringBuilder();
		for(String base36: base36List)	strBuild.append(base36);
		
		LOG.info("Encrypts plain text using the plugboard, then using the rotors.");
				
		return strBuild.toString();
	}
	
	/**
	 * Plugboard encryption.
	 * 
	 * @param wordCode directory wordCode
	 * @param wordIndex word index in plain text
	 * @return crypt word
	 */
	private int pbEncrypt(int wordCode, int wordIndex) {
		
		/* plugboard substitution
		 * each word is substituted using a different plugboard		*/
		int[] plugboard = pbMatrix[wordIndex % pbMatrix.length];
		
		int nWordCode = plugboard[wordCode];
		
		LOG.info("Encrypt text string using plugboard, wordCode: " +
			wordCode + ", nWordCode: " + nWordCode + ", wordIndex: " + wordIndex);
		
		return nWordCode;
	}
	
	/**
	 * Rotor encryption.
	 * 
	 * @param wordCode directory wordCode
	 * @return cryptWord
	 */
	private int rotorEncrypt(int wordCode) {
		
		LOG.info("START rotorEncrypt() wordCode: " + wordCode);

		// rotor encrypt
		for(int roID = 0; roID < roMatrix.length; roID++) {
			
			int[] rotor = roMatrix[roID];

			int index = ((roIndex[roID] + wordCode) % DIR_SIZE);
			int eWordCode = rotor[index];
			
			LOG.info("rotorIndex[" + roID + "]: " + roIndex[roID] +
				", wordCode: " + wordCode + ", index: " + index +
				", eWordCode: " + eWordCode);
			wordCode = eWordCode;
		}
		
		LOG.info("STOP rotorEncrypt() eWordCode: " + wordCode);
		
		stepRotors(roIndex);
		
		return wordCode;
	}
	
	private boolean wSpace = true;			// white space
	
	/**
	 * Decrypt crypt text.
	 * 
	 * @param cryptText
	 * @return plaint text
	 */
	public String decryptText(String cryptText) throws Exception {
		
		StringBuilder log;
		
		if(cryptText.length() % 3 != 0) {
			LOG.error("Encrypted text must be a multiple of three, cryptText: " + (cryptText.length() % 3));
			throw new Exception("cryptText incorrect length");
		}

		String[] cryptTextArr = cryptText.split("(?<=\\G.{3})");
		StringBuilder text = new StringBuilder();
		int[] base10List = new int[cryptTextArr.length];
			
		for(int i = 0; i < cryptTextArr.length; i++) {
			
			log = new StringBuilder();
			
				log.append("cryptText: ").append(cryptTextArr[i]).append("\t");
			base10List[i] = base36ToInt(cryptTextArr[i]);
				log.append("base36ToInt: ").append(base10List[i]).append("\t");
			
			int pbWordCode = -1, rWordCode = -1;
			for(int m = 0; m < ENCRYPT_MULTI; m++) {
				pbWordCode = pbDecrypt(base10List[i], i);
					log.append("pbD:").append(pbWordCode).append("\t");
				rWordCode = rotorDecrypt(pbWordCode);
					log.append("rD:").append(rWordCode).append("\t");
			}
				pbWordCode = pbDecrypt(rWordCode, i);
					log.append("rD:").append(pbWordCode).append("\t");

			String word = directory.getWord(pbWordCode);
				log.append("direcWord: ").append(word);

			if(word.equals("["))	wSpace = false;
			if(word.equals("]"))	wSpace = true;

			text.append(word.replace("[", "").replace("]", ""));
			if(wSpace)	text.append(" ");

			LOG.info(log.toString());
		}
		
		LOG.info("Decrypt encrypted text.");
		
		return text.toString().trim().toUpperCase().replaceAll("\\s{2,}", " ");
	}
	
	/**
	 * Plugboard decryption.
	 * 
	 * @param wordCode
	 * @param wordIndex word index in text
	 * @return 
	 */
	private int pbDecrypt(int wordCode, int wordIndex) {
		
		/* plugboard substitution
		 * each word is substituted using a different plugboard		*/
		int[] plugboard = pbMatrix[wordIndex % pbMatrix.length];
		
		int wordCodeIndex = -1;
		for(int i = 0; i < plugboard.length; i++)
			if(plugboard[i] == wordCode) {
				wordCodeIndex = i;
				break;
			}
		
		LOG.info("Decrypt text string using plugboard, wordCode: " +
			wordCode + ", wordCodeIndex: " + wordCodeIndex + ", wordIndex: " + wordIndex);
		
		return wordCodeIndex;
	}
	
	/**
	 * Rotor decryption.
	 * 
	 * @param eWordCode
	 * @return 
	 */
	private int rotorDecrypt(int eWordCode) {
		
		LOG.info("START rotorDecrypt() eWordCode: " + eWordCode);
		
		// rotor decrypt
		for(int roID = roMatrix.length - 1; roID >= 0; roID--) {
			
			int[] rotor = roMatrix[roID];

			for(int index = 0; index < rotor.length; index++)
				if(rotor[index] == eWordCode) {
					
					int newWordCode = ((((index - roIndex[roID]) % DIR_SIZE) + DIR_SIZE) % DIR_SIZE);
					LOG.info("roID: " + roID + ", eWordCode: " + eWordCode +
						", index: " + index + ", rotorIndex[" + roID + "]: " +
						roIndex[roID] + ", newWordCode: " + newWordCode);
					
					eWordCode = newWordCode;
					break;
				}
		}
		
		LOG.info("STOP rotorDecrypt() eWordCode: " + eWordCode);
		
		stepRotors(roIndex);
		
		return eWordCode;
	}
	
	/** Base 10 to Base 36.		*/
	private static String intToBase36(int base10) {
		return Integer.toString(base10, Character.MAX_RADIX);
	}
	
	/** Base 36 to Base 10.		*/
	private static int base36ToInt(String base36) {
		return Integer.parseInt(base36, Character.MAX_RADIX);
	}
	
	public static String longToBase36(long base10) {
		return Long.toString(base10, Character.MAX_RADIX);
	}

	/**
	 * Text to pad.
	 * 
	 * @param str string to pad
	 * @param length desired string length
	 * @return padded string
	 */
	private static String padText(String str, int length) {

		if((length - str.length()) > 0)		return padText("0" + str, length);
		return str;
	}
	
	/** String to long hash using SipHash 64bit.			*/
	private static long hashCode(String str) {

		// java jashCode
//		long hash = 0;
//		
//		if(str.length() > 0) {
//			char val[] = str.toCharArray();
//			for(int i = 0; i < str.length(); i++)
//				hash = 31 * hash + val[i];
//		}
//
//		return hash;

		SipHash hasher = new SipHash("navaile_Enigma4K".getBytes());
		return hasher.hash(str.getBytes()).get();
	}

	private long nextSeed() {			return RND.nextLong();				}
	private int nextSeed(int bound) {	return RND.nextInt(bound);			}
	private boolean nextBool() {		return RND.nextBoolean();			}
	
	private static int[] seqRotor;		// sequential rotor 0,1,2,3, ...
	
	/**
	 * Builds a random rotor or plugboard.
	 * 
	 * @return a new rotor
	 */
	private static int[] genRotorPb(long seed) {
		
		Random rnd = new Random(seed);

		if(seqRotor == null) {
			seqRotor = new int[Enigma4K.DIR_SIZE];		// 46655, ZZZ
			for(int i = 0; i < seqRotor.length; i++)		seqRotor[i] = i;
		}
		
		int[] arr = seqRotor.clone();
		
		// Fisher–Yates shuffle
		// [0, 1, 2, 3, 4]
		for(int i = arr.length - 1; i > 0; i--) {
			
			int index = rnd.nextInt(i + 1);
			// Simple swap
			int a = arr[index];
			arr[index] = arr[i];
			arr[i] = a;
		}

		return arr;
	}
	
	private static void memory() {
		
		long MEGABYTE = 1024L * 1024L;

		Runtime runtime = Runtime.getRuntime();
		NumberFormat format = NumberFormat.getInstance();

		StringBuilder sb = new StringBuilder();
		long maxMemory = runtime.maxMemory();
		long allocatedMemory = runtime.totalMemory();
		long freeMemory = runtime.freeMemory();

		sb.append("free memory: ").append(format.format(freeMemory / MEGABYTE)).append("\n");
		sb.append("allocated memory: ").append(format.format(allocatedMemory / MEGABYTE)).append("\n");
		sb.append("max memory: ").append(format.format(maxMemory / MEGABYTE)).append("\n");
		sb.append("total free memory: ").append(format.format((freeMemory + (maxMemory - allocatedMemory)) / MEGABYTE)).append("\n");
		
		System.out.println(sb.toString());
	}

	/**
	 * @param args the command line arguments
	 */
	public static void main(String[] args) {
		
		BasicConfigurator.configure();
		org.apache.log4j.Logger logger4j = org.apache.log4j.Logger.getRootLogger();
			logger4j.setLevel(org.apache.log4j.Level.toLevel("ERROR"));
		
		String msgID = Enigma4K.genMsgID();
		String path = "src/main/resources/directory";
		Enigma4K enigma = new Enigma4K(path, "password", "vladpaln", msgID, 5000, 500);
		
		String textLine = "this is a test of the emergency broadcast system.";
		String repeat = "this this this this this zzzz didn't ` ~ ? : ; \" ' _ | / * - + = . , < > ! $ ( ) %";
		
		String encTextLine = null;
		String encRepeat = null;
		try {
			encTextLine = enigma.encryptText(textLine);
			encRepeat = enigma.encryptText(repeat);
		}
		catch(Exception e) {
			LOG.error("Encrypt Error", e);
		}
		
		String decTextLine = null, decRepeat = null;

		try {
			Enigma4K.resetKey();
			decTextLine = enigma.decryptText(encTextLine);
			decRepeat = enigma.decryptText(encRepeat);
		}
		catch(Exception ex) {	LOG.error("Decrypt Text", ex);				}

		System.out.println("original: " + textLine);
		System.out.println("encoded: " + encTextLine);
		System.out.println("decoded: " + decTextLine);
		
		System.out.println("original: " + repeat);
		System.out.println("encoded: " + encRepeat);
		System.out.println("decoded: " + decRepeat);
	}
}

