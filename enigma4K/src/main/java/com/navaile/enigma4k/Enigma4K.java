/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.navaile.enigma4k;

import com.zackehh.siphash.*;
import java.text.NumberFormat;
import java.util.*;
import org.apache.log4j.*;

/**
 * A next generation Enigma based on the original design.
 * 
 * Software Design
 * The software was designed with a laymen in mind.
 *
 * @author navaile
 */
public class Enigma4K {
	
	private static final Logger LOG = Logger.getLogger(Enigma4K.class);

	/** Directory size.					*/
	public static final int DIR_SIZE = 46_655;				// ZZZ (base36)

	/** Number of rotors in the enigma machine.		*/
	public static final int COUNT_MIN = 97;
	public static final int COUNT_MAX = 46_655;			// ZZZ (base36)
	public static final int RO_COUNT_LOCK = 4_000;
	public static final int PB_COUNT_LOCK = 500;
	
	/** Hash key, used to generate seeds. Feel free to change.		*/
	public static String hashKey = "navaile_Enigma4K";
	
	/** Encryption/decryption multiplier.						*/
	private static final int CRYPT_MULTI_MAX = 97;
	private static int CRYPT_MULTI = 7;
	
	/**
	 * Rotor/Plugboard Permutations
	 * 
	 * perm		= factorial(rotorSize)
	 *			= 46,655!
	 *			= 1.478143766589091023060 x 10^197568
	 *			= 10^10^5.295716976537452
	 */
	
	private static Random RND;
	private static Directory directory;

	/** Matrix used for encryption, if false matrix is inverted.		*/
	private static boolean encrypt = true;
	
	private static int[][] roMatrix;
	private static int[][] pbMatrix;
	
//	/** Inverse for fast decryption.	*/
//	// doubles memory usage, speed increase 50x
//	private static int[][] invRoMatrix;
//	private static int[][] invPbMatrix;
	
	/** Rotor Key		*/			private static int[] roKey;
	/** Index for each rotor */		private static int[] roIndex;
	/** Rotor Direction */			private static int[] roDirectionSpin;
	/** Rotor Step Size */			private static int[] roStepSize;
	
	/**
	 * Builds a new enigma machine.
	 * 
	 * @param passPhrase pass phrase, password
	 * @param handle recipient name/email/handle
	 * @param msgID msgID generated by Enigma4K.genMsgID()
	 * @param roCount rotor count, 97 - 5000
	 * @param pbCount plugboard count, 97 - 500
	 */
	public Enigma4K(String passPhrase, String handle, String msgID, int roCount, int pbCount) {
		
		LOG.info("ini AdvEnigma(" + roCount + ", " + pbCount + ")");
		
		directory = Directory.getInstance();

		passPhrase = passPhrase + "_" + handle + (msgID != null ? ("_" + msgID) : "");
		LOG.info("passPhrase: " + passPhrase + ", handle: " + handle + ", msgID: " + msgID);

		RND = new Random(hashCode(passPhrase));
		CRYPT_MULTI = nextSeed(CRYPT_MULTI_MAX);

		if(roCount < COUNT_MIN)			roCount = COUNT_MIN;
		if(pbCount < COUNT_MIN)			pbCount = COUNT_MIN;
		if(roCount > RO_COUNT_LOCK)		roCount = RO_COUNT_LOCK;	// 4,000
		if(pbCount > PB_COUNT_LOCK)		pbCount = PB_COUNT_LOCK;	// 500 (2 pages)
		
		LOG.info("ini AdvEnigma: genKey, copy to rotorIndex");
		Enigma4K.roKey = genKey(roCount);
		Enigma4K.roIndex = Enigma4K.roKey.clone();
		
		Enigma4K.roDirectionSpin = new int[Enigma4K.roKey.length];
		for(int i = 0; i < Enigma4K.roDirectionSpin.length; i++)
			Enigma4K.roDirectionSpin[i] = (nextBool() ? 1 : -1);
		
		Enigma4K.roStepSize = new int[Enigma4K.roKey.length];
		for(int i = 0; i < Enigma4K.roStepSize.length; i++)
			Enigma4K.roStepSize[i] = nextSeed(31 + 1);
		
		LOG.info("ini AdvEnigma: generate random rotors/plugboards");

		Enigma4K.roMatrix = new int[roCount][];
		for(int i = 0; i < roMatrix.length; i++) {
			if(encrypt)		roMatrix[i] = genRotorPb(nextSeed());
			else			roMatrix[i] = invArr(genRotorPb(nextSeed()));
		}
		
		Enigma4K.pbMatrix = new int[pbCount][];
		for(int i = 0; i < pbMatrix.length; i++) {
			if(encrypt)		pbMatrix[i] = genRotorPb(nextSeed());
			else			pbMatrix[i] = invArr(genRotorPb(nextSeed()));
		}
		
		memory();
		
		LOG.info("Rotor Count: " + roCount);
		LOG.info("Rotor Key: " + Arrays.toString(roKey));
		LOG.info("Rotor Direction: " + Arrays.toString(Enigma4K.roDirectionSpin));
		LOG.info("Rotor Step Size: " + Arrays.toString(Enigma4K.roStepSize));
		LOG.info("Plugboard Count: " + pbCount);
	}
	
	/**
	 * Generate message id.
	 * 
	 * @return 
	 */
	public static String genMsgID() {
		
		StringBuilder time = new StringBuilder();
		Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
			time.append(cal.get(Calendar.SECOND))
				.append(cal.get(Calendar.MINUTE))
				.append(cal.get(Calendar.HOUR_OF_DAY))
				.append(cal.get(Calendar.DAY_OF_YEAR))
				.append(cal.get(Calendar.YEAR));
			
		long msgID = Long.parseLong(time.toString());

		return padText(longToBase36(msgID).toUpperCase(), 9);
	}

	/** Steps/rotates rotor after each word encryption.		*/
	private static void stepRotors(int[] rotorIndex) {

		for(int i = 0; i < rotorIndex.length; i++) {
			
			rotorIndex[i] += roStepSize[i] * roDirectionSpin[i];

			if(rotorIndex[i] >= DIR_SIZE) rotorIndex[i] = rotorIndex[i] % DIR_SIZE;
			else if(rotorIndex[i] < 0) rotorIndex[i] = DIR_SIZE + rotorIndex[i];
		}
		
		LOG.info("stepRotors() new rotor settings: " + Arrays.toString(rotorIndex));
	}
	
	/**
	 * Generates a new rotor key.
	 * 
	 * @return a random key
	 */
	private static int[] genKey(int rotorCount) {
		
		LOG.info("Generates random rotor key.");
		
		int[] newKey = new int[rotorCount];
		for (int i = 0; i < newKey.length; i++)
			newKey[i] = RND.nextInt(DIR_SIZE);

		return newKey.clone();
	}
	
	/** Resets rotor key.	*/
	public void resetKey() {
		Enigma4K.roIndex = Enigma4K.roKey.clone();
		LOG.info("AdvEnigma.resetKey() key: " + Arrays.toString(Enigma4K.roKey));
	}
	
	/**
	 * Static encryption.
	 * 
	 * @param passPhrase pass phrase or password
	 * @param handle recipient email, handle, or name
	 * @param roCount rotor count
	 * @param pbCount plugboard count
	 * @param dirSeed directory randomization seed, default is null
	 * @param plainText text message to encrypt
	 * @return encrypted text
	 * @throws Exception 
	 */
	public static String encryptText(String passPhrase, String handle,
		int roCount, int pbCount, Long dirSeed, String plainText) throws Exception {
		
		encrypt = true;
		
		String msgID = Enigma4K.genMsgID();
		Enigma4K enigma = new Enigma4K(passPhrase, handle, msgID, roCount, pbCount);
			enigma.randomizeDirectory(dirSeed);
		
		return msgID + enigma.encryptText(plainText);
	}
	
	/**
	 * Encrypt text.
	 * 
	 * @param plainText plaint text to be encrypted
	 * @return crypt text
	 */
	public String encryptText(String plainText) throws Exception {
		
		LOG.info("Enigma4K.encryptText(" + plainText + ")");
		
		encrypt = true;
		
		StringBuilder log = new StringBuilder();

		String[] wordList = directory.parceWords(plainText.toLowerCase());
		ArrayList<Integer> wordCodeList = new ArrayList<>();
		
		LOG.info("Enigma4K.encryptText().wordList.length: " + wordList.length);
		
		for (String word: wordList) {

			Integer wordCode = directory.getKeyCode(word);
			log.append(word).append(": ").append(wordCode).append("\t");
			
			if(wordCode == null) {
				
				LOG.debug("Enigma4K.encryptText word:" + word + ", wordCode:" + wordCode);
				
				char[] letters = word.toCharArray();
				
				LOG.debug("Enigma4K.encryptText letter arr: " + Arrays.toString(letters));
				
				wordCodeList.add(directory.getKeyCode("<%"));
				for(char l: letters) {
					
					Integer keyCode = directory.getKeyCode(String.valueOf(l));
					wordCodeList.add(keyCode);

					if(keyCode == null)
						System.out.println("null keyCode for char: " + l + "|" + Character.getNumericValue(l));
				}
				wordCodeList.add(directory.getKeyCode("%>"));
			}
			else {		wordCodeList.add(wordCode);						}
		}
		
		LOG.debug(log.toString());
		log = new StringBuilder();
		
		String[] base36List = new String[wordCodeList.size()];
		
		LOG.debug("Enigma4K.encryptText.wordCodeList: " + wordCodeList.size());
		LOG.debug("Enigma4K.encryptText.wordCodeList.data: " + Arrays.toString(wordCodeList.toArray()));
		
		// wordCodeList check
		LOG.debug("wordCodeList: " + Arrays.toString(wordCodeList.toArray()));
		
		for(Integer wordCode: wordCodeList)
			if(wordCode == null)	throw new Exception("Unable to encrypt null.");

		int i = 0;
		for(int wordCode: wordCodeList) {
			
			int pbWordCode = -1, rWordCode = -1;
			for(int m = 0; m < CRYPT_MULTI; m++) {
				pbWordCode = pbEncrypt(wordCode, i);
					log.append("pbE:").append(pbWordCode).append("\t");
				rWordCode = rotorEncrypt(pbWordCode);
					log.append("rE:").append(rWordCode).append("\t");
			}
				pbWordCode = pbEncrypt(rWordCode, i);
					log.append("pbE:").append(pbWordCode).append("\t");

			String base36Str = padText(intToBase36(pbWordCode), 3).toUpperCase();
			base36List[i] = base36Str;
				log.append("base36: ").append(base36Str);
				
			i++;
			
			LOG.info(log.toString());
		}
		
		StringBuilder strBuild = new StringBuilder();
		for(String base36: base36List)	strBuild.append(base36);
		
		LOG.info("Encrypts plain text using the plugboard, then using the rotors.");
				
		return strBuild.toString();
	}
	
	/**
	 * Plugboard encryption.
	 * 
	 * @param wordCode directory wordCode
	 * @param wordIndex word index in plain text
	 * @return crypt word
	 */
	private int pbEncrypt(int wordCode, int wordIndex) {
		
		/* plugboard substitution
		 * each word is substituted using a different plugboard		*/
		int[] plugboard = pbMatrix[wordIndex % pbMatrix.length];
		int nWordCode = plugboard[wordCode];
		
		LOG.info("Encrypt text string using plugboard, wordCode: " +
			wordCode + ", nWordCode: " + nWordCode + ", wordIndex: " + wordIndex);
		
		return nWordCode;
	}
	
	/**
	 * Rotor encryption.
	 * 
	 * @param wordCode directory wordCode
	 * @return cryptWord
	 */
	private int rotorEncrypt(int wordCode) {
		
		LOG.info("START rotorEncrypt() wordCode: " + wordCode);

		// rotor encrypt
		for(int roID = 0; roID < roMatrix.length; roID++) {
			
			int[] rotor = roMatrix[roID];

			int index = ((roIndex[roID] + wordCode) % DIR_SIZE);
			int eWordCode = rotor[index];
			
			LOG.info("rotorIndex[" + roID + "]: " + roIndex[roID] +
				", wordCode: " + wordCode + ", index: " + index +
				", eWordCode: " + eWordCode);
			wordCode = eWordCode;
		}
		
		LOG.info("STOP rotorEncrypt() eWordCode: " + wordCode);
		
		stepRotors(roIndex);
		
		return wordCode;
	}
	
	/**
	 * Static decryption.
	 * 
	 * @param passPhrase pass phrase or password
	 * @param handle recipient email, handle, or name
	 * @param roCount rotor count
	 * @param pbCount plugboard count
	 * @param dirSeed directory randomization seed, default is null
	 * @param cryptText text message to encrypt
	 * @return plain text
	 * @throws Exception 
	 */
	public static String decryptText(String passPhrase, String handle,
		int roCount, int pbCount, Long dirSeed, String cryptText) throws Exception {
		
		encrypt = false;
		
		String msgID = cryptText.substring(0, 9);
		cryptText = cryptText.substring(9, cryptText.length());
						
		Enigma4K enigma = new Enigma4K(passPhrase, handle, msgID, roCount, pbCount);
			enigma.randomizeDirectory(dirSeed);
		
		return enigma.decryptText(cryptText);
	}
	
	private boolean wSpace = true;			// white space
	
	/**
	 * Decrypt crypt text.
	 * 
	 * @param cryptText
	 * @return plaint text
	 */
	public String decryptText(String cryptText) throws Exception {
		
		encrypt = false;
		
		StringBuilder log;
		
		if(cryptText.length() % 3 != 0) {
			LOG.error("Encrypted text must be a multiple of three, cryptText: " + (cryptText.length() % 3));
			throw new Exception("cryptText incorrect length");
		}

		String[] cryptTextArr = cryptText.split("(?<=\\G.{3})");
		StringBuilder text = new StringBuilder();
		int[] base10List = new int[cryptTextArr.length];
			
		for(int i = 0; i < cryptTextArr.length; i++) {
			
			log = new StringBuilder();
			
				log.append("cryptText: ").append(cryptTextArr[i]).append("\t");
			base10List[i] = base36ToInt(cryptTextArr[i]);
				log.append("base36ToInt: ").append(base10List[i]).append("\t");
			
			int pbWordCode = -1, rWordCode = -1;
			for(int m = 0; m < CRYPT_MULTI; m++) {
				pbWordCode = pbDecrypt(base10List[i], i);
					log.append("pbD:").append(pbWordCode).append("\t");
				rWordCode = rotorDecrypt(pbWordCode);
					log.append("rD:").append(rWordCode).append("\t");
			}
				pbWordCode = pbDecrypt(rWordCode, i);
					log.append("rD:").append(pbWordCode).append("\t");

			String word = directory.getWord(pbWordCode);
				word = word.replace("\\s,", ",");
				word = word.replace("\\s.", ".");
				log.append("direcWord: ").append(word);

			if(word.equals("<%"))	wSpace = false;
			if(word.equals("%>"))	wSpace = true;

			text.append(word.replace("<%", "").replace("%>", ""));
			if(wSpace)	text.append(" ");

			LOG.info(log.toString());
		}

		LOG.info("Decrypt encrypted text.");
		
		return text.toString()
			.trim()
			.toUpperCase()
			.replaceAll("\\s{2,}", " ")			// replace multiple spaces
			.replaceAll(" :", ":")				// remove spaces before colon
			.replaceAll(" ;", ";")				// remove spaces before semicolon
			.replaceAll(" ,", ",")				// remove spaces before commas
			.replaceAll(" \\.", ".");			// remove spaces before period
	}
	
	/**
	 * Plugboard decryption.
	 * 
	 * @param wordCode
	 * @param wordIndex word index in text
	 * @return 
	 */
	private int pbDecrypt(int wordCode, int wordIndex) {
		
		LOG.info("Enigma4K.pbDecrypt()");
		
		/* plugboard substitution
		 * each word is substituted using a different plugboard		*/
//		int[] plugboard = pbMatrix[wordIndex % pbMatrix.length];
		int[] plugboard = pbMatrix[wordIndex % pbMatrix.length];
		
//		int wordCodeIndex = -1;
//		for(int i = 0; i < plugboard.length; i++)
//			if(plugboard[i] == wordCode) {
//				wordCodeIndex = i;
//				break;
//			}
//
//		LOG.info("Decrypt text string using plugboard, wordCode: " +
//			wordCode + ", wordCodeIndex: " + wordCodeIndex + ", wordIndex: " + wordIndex);
		
		return plugboard[wordCode];
	}
	
	/**
	 * Rotor decryption.
	 * 
	 * @param wordCode
	 * @return 
	 */
	private int rotorDecrypt(int wordCode) {
		
		LOG.info("START rotorDecrypt() eWordCode: " + wordCode);
		
		// rotor decrypt
		for(int roID = roMatrix.length - 1; roID >= 0; roID--) {

			int[] rotor = roMatrix[roID];
			int newWordCode = ((((rotor[wordCode] - roIndex[roID]) % DIR_SIZE) + DIR_SIZE) % DIR_SIZE);
			LOG.info("roID: " + roID + ", eWordCode: " + wordCode +
				", rotorIndex[" + roID + "]: " + roIndex[roID] +
				", newWordCode: " + newWordCode);

			wordCode = newWordCode;
		}
		
		LOG.info("STOP rotorDecrypt() eWordCode: " + wordCode);
		stepRotors(roIndex);
		return wordCode;
	}
	
	/** Base 10 to Base 36.		*/
	private static String intToBase36(int base10) {
		return Integer.toString(base10, Character.MAX_RADIX);
	}
	
	/** Base 36 to Base 10.		*/
	private static int base36ToInt(String base36) {
		return Integer.parseInt(base36, Character.MAX_RADIX);
	}
	
	public static String longToBase36(long base10) {
		return Long.toString(base10, Character.MAX_RADIX);
	}

	/**
	 * Text to pad.
	 * 
	 * @param str string to pad
	 * @param length desired string length
	 * @return padded string
	 */
	private static String padText(String str, int length) {

		if((length - str.length()) > 0)		return padText("0" + str, length);
		return str;
	}
	
	/** String to long hash using SipHash 64bit.			*/
	private static long hashCode(String str) {

		// java jashCode
//		long hash = 0;
//		
//		if(str.length() > 0) {
//			char val[] = str.toCharArray();
//			for(int i = 0; i < str.length(); i++)
//				hash = 31 * hash + val[i];
//		}
//
//		return hash;

		SipHash hasher = new SipHash(hashKey.getBytes());
		return hasher.hash(str.getBytes()).get();
	}

	private long nextSeed() {			return RND.nextLong();				}
	private int nextSeed(int bound) {	return RND.nextInt(bound);			}
	private boolean nextBool() {		return RND.nextBoolean();			}
	
	private static int[] seqRotor;		// sequential rotor 0,1,2,3, ...
	
	/**
	 * Builds a random rotor or plugboard.
	 * 
	 * @return a new rotor
	 */
	private static int[] genRotorPb(long seed) {
		
		Random rnd = new Random(seed);

		if(seqRotor == null) {
			seqRotor = new int[Enigma4K.DIR_SIZE];			// 46655, ZZZ
			for(int i = 0; i < seqRotor.length; i++)		seqRotor[i] = i;
		}
		
		int[] arr = seqRotor.clone();
		Util.shuffle(rnd, arr);
		return arr;
	}
	
	/**
	 * Array inversion, index and value switch.
	 * 
	 * @param arr
	 * @return 
	 */
	private static int[] invArr(int[] arr) {
		
		int[] invArr = new int[arr.length];
		
		for(int index = 0; index < arr.length; index++) {
			int val = arr[index];
			invArr[val] = index;
		}
		
		return invArr;
	}
	
	/**
	 * This method will randomize the directory based on the seed supplied.
	 * Randomizing the directory increases security however both parties must
	 * use the same seed when randomizing the directory to ensure that both
	 * parties have the same directory.
	 */
	public void randomizeDirectory(Long seed) {
		if(directory != null && seed != null)
			directory.randomizeDirectory(seed);
	}
	
	private static void memory() {
		
		long MEGABYTE = 1024L * 1024L;

		Runtime runtime = Runtime.getRuntime();
		NumberFormat format = NumberFormat.getInstance();

		StringBuilder sb = new StringBuilder();
		long maxMemory = runtime.maxMemory();
		long allocatedMemory = runtime.totalMemory();
		long freeMemory = runtime.freeMemory();

		sb.append("free memory: ").append(format.format(freeMemory / MEGABYTE)).append("\n");
		sb.append("allocated memory: ").append(format.format(allocatedMemory / MEGABYTE)).append("\n");
		sb.append("max memory: ").append(format.format(maxMemory / MEGABYTE)).append("\n");
		sb.append("total free memory: ").append(format.format((freeMemory + (maxMemory - allocatedMemory)) / MEGABYTE)).append("\n");
		
		System.out.println(sb.toString());
	}

//	/**
//	 * @param args the command line arguments
//	 */
//	public static void main(String[] args) {
//		
//		BasicConfigurator.configure();
//		Logger.getRootLogger().setLevel(Level.ERROR);
//		
//		String password = "password";
//		String handle = "handle";
//		
//		String[] textLine = new String[] {
//			"this is a test of the emergency broadcast system.",
//			"",
//			""
//		};
//
//		String[] repeat = new String[] {
//			"supercalifragilisticexpialidocious this zzzz didn't ` ~ ? : ; \" ' _ | / * - + = . , < > ! $ ( ) [ ] { } @ # % ^ &",
//			"",
//			""
//		};
//
//		try {
//			textLine[1] = Enigma4K.encryptText(password, handle, 103, 103, null, textLine[0]);
//			repeat[1] = Enigma4K.encryptText(password, handle, 103, 103, null, repeat[0]);
//		}
//		catch(Exception e) {
//			LOG.error("Encrypt Error", e);
//		}
//
//		try {
//			textLine[2] = Enigma4K.decryptText(password, handle, 103, 103, null, textLine[1]);
//			repeat[2] = Enigma4K.decryptText(password, handle, 103, 103, null, repeat[1]);
//		}
//		catch(Exception ex) {
//			LOG.error("Decrypt Text", ex);
//		}
//		
//		for(String line: textLine)	System.out.println(line);
//		for(String line: repeat)	System.out.println(line);
//	}
}

