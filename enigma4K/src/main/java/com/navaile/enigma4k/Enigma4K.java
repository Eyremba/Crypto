/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.navaile.enigma4k;

import com.zackehh.siphash.*;
import java.text.NumberFormat;
import java.util.*;
import org.apache.log4j.*;

/**
 * Enigma Mk II based on the original, attempts have been made to remove known
 * weaknesses.
 * 
 * Rotor/Plugboard Permutations
 * perm		= factorial(rotorSize)
 *			= 46,655!
 *			= 1.478143766589091023060 x 10^197568
 *			= 10^10^5.295716976537452
 * 
 * Known Limitations
 * Rotor/plugboard variations are limited by 64bit seed.
 * = (64bit permutations) / (rotor/pb permutations)
 * = (9.22 x 10^18 * 2) / (1.478 x 10^197568)
 * = only a tiny percent of all possible permutations is possible due to the
 *		limitations of current computer architecture
 * 
 * random seed size of:
 * 10^197568 = 2^x
 * x = 197568*ln(10)/ln(2)
 * x = 656306.68
 * 2^656306.68 size long seed required for all ro/pb permutations
 *
 * @author navaile
 */
public class Enigma4K {
	
	private static final Logger LOG = Logger.getLogger(Enigma4K.class);

	/** Directory size.							*/
	public static final int DIR_SIZE = 46_655;			// ZZZ (base36)

	/** Number of rotors in the enigma machine.	*/
	public static final int COUNT_MIN = 97;
	public static final int COUNT_MAX = 46_655;			// ZZZ (base36)
	private static final int RO_COUNT_MAX = 4_000;
	private static final int PB_COUNT_MAX = 500;		// 500 (2 pages of text)
	
	/** Hash key, used to generate seeds. Feel free to change.		*/
	private static final String hashKey = "navaile_Enigma4K";
	
	private final Random RND;
	private static Directory directory;

	/** Matrix used for encryption, if false matrix is inverted.		*/
	private static boolean encrypt = true;
	
	private final int[][] roMatrix;
	private final int[][] pbMatrix;
	
	/** Rotor Key		*/			private final int[] roKey;
	/** Index for each rotor */		private int[] roIndex;
	/** Rotor Direction */			private int[] roDirectionSpin;
	
	/**
	 * Builds Crypto, configures settings.
	 * 
	 * @param passPhrase pass phrase, password
	 * @param handle recipient name/email/handle
	 * @param msgID msgID generated by Enigma4K.genMsgID()
	 * @param roCount rotor count, 97 - 5000
	 * @param pbCount plugboard count, 97 - 500
	 */
	public Enigma4K(String passPhrase, String handle, String msgID, int roCount, int pbCount) {

		LOG.info("ini AdvEnigma()");

		directory = Directory.getInstance();

		passPhrase = passPhrase + "_" + handle + (msgID != null ? ("_" + msgID) : "");
		LOG.info("passPhrase: " + passPhrase + ", handle: " + handle + ", msgID: " + msgID);

		RND = new Random(hashCode(passPhrase));

		if(roCount < COUNT_MIN)			roCount = COUNT_MIN;
		if(pbCount < COUNT_MIN)			pbCount = COUNT_MIN;
		if(roCount > RO_COUNT_MAX)		roCount = RO_COUNT_MAX;		// 4,000
		if(pbCount > PB_COUNT_MAX)		pbCount = PB_COUNT_MAX;		// 500 (2 pages)
		
		// ro/pb random count
		roCount = (int)( (roCount * .75) + (roCount * (RND.nextFloat() * .25)) );
		pbCount = (int)( (pbCount * .75) + (pbCount * (RND.nextFloat() * .25)) );

		LOG.info("ini AdvEnigma(" + roCount + ", " + pbCount + ")");
		
		LOG.info("ini AdvEnigma: genKey, copy to rotorIndex");
		roKey = genKey(roCount);
		roIndex = roKey.clone();
		
		roDirectionSpin();
		
		LOG.info("ini AdvEnigma: generate random rotors/plugboards");

		roMatrix = new int[roCount][];
		for(int i = 0; i < roMatrix.length; i++) {
			if(encrypt)		roMatrix[i] = genRotorPb(RND.nextLong());
			else			roMatrix[i] = invArr(genRotorPb(RND.nextLong()));
		}				
		
		pbMatrix = new int[pbCount][];
		for(int i = 0; i < pbMatrix.length; i++) {
			if(encrypt)		pbMatrix[i] = genRotorPb(RND.nextLong());
			else			pbMatrix[i] = invArr(genRotorPb(RND.nextLong()));
		}
		
		memory();
		
		LOG.info("Rotor Count: " + roCount);
		LOG.info("Rotor Key: " + Arrays.toString(roKey));
		LOG.info("Rotor Direction: " + Arrays.toString(roDirectionSpin));
		LOG.info("Plugboard Count: " + pbCount);
	}
	
	/**
	 * Generate message id.
	 * 
	 * @return message id
	 */
	public static String genMsgID() {
		
		StringBuilder time = new StringBuilder();
		Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
			time.append(cal.get(Calendar.SECOND))
				.append(cal.get(Calendar.MINUTE))
				.append(cal.get(Calendar.HOUR_OF_DAY))
				.append(cal.get(Calendar.DAY_OF_YEAR))
				.append(cal.get(Calendar.YEAR));
			
		long msgID = Long.parseLong(time.toString());

		return padText(longToBase36(msgID).toUpperCase(), 9);
	}
	
	/** Sets rotor direction spin.							*/
	private void roDirectionSpin() {
		
		roDirectionSpin = new int[roKey.length];
		for(int i = 0; i < roDirectionSpin.length; i++)
			roDirectionSpin[i] = (RND.nextBoolean() ? 1 : -1);
	}

	/** Steps/rotates rotor after each word encryption.		*/
	private void stepRotors(int[] rotorIndex) {
		
		if(RND.nextDouble() > .9955)		roDirectionSpin();

		for(int i = 0; i < rotorIndex.length; i++) {
			rotorIndex[i] += RND.nextInt(31) * roDirectionSpin[i];
			if(rotorIndex[i] >= DIR_SIZE) rotorIndex[i] = rotorIndex[i] % DIR_SIZE;
			else if(rotorIndex[i] < 0) rotorIndex[i] = DIR_SIZE + rotorIndex[i];
		}
		
		LOG.info("stepRotors() new rotor settings: " + Arrays.toString(rotorIndex));
	}

	/**
	 * Generates a new rotor key.
	 * 
	 * @return a random key
	 */
	private int[] genKey(int rotorCount) {
		
		LOG.info("Enigma4K.genKey() Generates random rotor key.");
		
		int[] newKey = new int[rotorCount];
		for (int i = 0; i < newKey.length; i++)
			newKey[i] = RND.nextInt(DIR_SIZE);

		return newKey.clone();
	}
	
	private int[] seqRoOrder;		// sequential rotor order 0,1,2,3, ...
	
	/**
	 * Randomize rotor order.
	 * 
	 * @return a new rotor order
	 */
	private int[] rndOrder(Random rnd) {

		if(seqRoOrder == null) {
			seqRoOrder = new int[roKey.length];
			for(int i = 0; i < seqRoOrder.length; i++)		seqRoOrder[i] = i;
		}
	
		int[] newOrder = seqRoOrder.clone();
		Util.shuffle(rnd, newOrder);
		return newOrder;
	}
	
	/** Resets rotor key.	*/
	protected void resetKey() {
		roIndex = roKey.clone();
		LOG.info("Enigma4K.resetKey() key: " + Arrays.toString(roKey));
	}
	
	/**
	 * Static encryption.
	 * 
	 * @param passPhrase pass phrase or password
	 * @param handle recipient email, handle, or name
	 * @param roCount rotor count
	 * @param pbCount plugboard count
	 * @param dirSeed directory randomization seed, default is null
	 * @param plainText text message to encrypt
	 * @return encrypted text
	 * @throws Exception 
	 */
	public static String encryptText(String passPhrase, String handle,
		int roCount, int pbCount, Long dirSeed, String plainText) throws Exception {
		
		encrypt = true;
		
		String msgID = Enigma4K.genMsgID();
		Enigma4K enigma = new Enigma4K(passPhrase, handle, msgID, roCount, pbCount);
			enigma.randomizeDirectory(dirSeed);
		
		return msgID + enigma.encryptText(plainText);
	}
	
	/**
	 * Encrypt text.
	 * 
	 * @param plainText plaint text to be encrypted
	 * @return crypt text
	 */
	private String encryptText(String plainText) throws Exception {
		
		LOG.info("Enigma4K.encryptText(" + plainText + ")");
		
		encrypt = true;
		
		StringBuilder log = new StringBuilder();

		String[] wordList = directory.parceWords(plainText.toLowerCase());
		ArrayList<Integer> wordCodeList = new ArrayList<>();
		
		LOG.debug("Enigma4K.encryptText().wordList.length: " + wordList.length);
		LOG.debug("Enigma4K.encryptText().wordList.data: " + Arrays.toString(wordList));
		
		for (String word: wordList) {

			Integer wordCode = directory.getKeyCode(word);
			log.append(word).append(": ").append(wordCode).append(", ");
			
			if(wordCode == null) {

				LOG.debug("Enigma4K.encryptText letter: " + Arrays.toString(word.toCharArray()));
				
				wordCodeList.add(directory.getKeyCode("<%"));
				for(char l: word.toCharArray()) {
					Integer keyCode = directory.getKeyCode(String.valueOf(l));
					if(keyCode != null)		wordCodeList.add(keyCode);
				}
				wordCodeList.add(directory.getKeyCode("%>"));
			}
			else {		wordCodeList.add(wordCode);						}
		}
		
		LOG.debug(log.toString());
		
		LOG.debug("Enigma4K.encryptText.wordCodeList: " + wordCodeList.size());
		LOG.debug("Enigma4K.encryptText.wordCodeList.data: " + Arrays.toString(wordCodeList.toArray()));
		
		// wordCodeList check
		LOG.debug("wordCodeList: " + Arrays.toString(wordCodeList.toArray()));
		
		StringBuilder strBuild = new StringBuilder();

		for(int wordCode: wordCodeList) {
			
			log = new StringBuilder();
			log.append("wordCode:").append(wordCode).append(", ");

			int index = RND.nextInt(pbMatrix.length);
			wordCode = pbCrypt(wordCode, index);
				log.append("pbE:").append(wordCode).append(", ");
			wordCode = roCrypt(wordCode);
				log.append("rE:").append(wordCode).append(", ");
			wordCode = pbCrypt(wordCode, index);
				log.append("pbE:").append(wordCode).append(", ");

			String base36Str = padText(intToBase36(wordCode), 3).toUpperCase();
				strBuild.append(base36Str);
				log.append("base36:").append(base36Str);
			
			LOG.debug(log.toString());
		}
		
		LOG.info("Encrypts plain text using the plugboard, then using the rotors.");
				
		return strBuild.toString();
	}
	
	/**
	 * Plugboard encryption/decryption.
	 * 
	 * @param wordCode directory wordCode
	 * @param pbIndex word index in plain text
	 * @return crypt word
	 */
	private int pbCrypt(int wordCode, int pbIndex) {
		
		/* plugboard substitution
		 * each word is substituted using a different plugboard		*/
		int[] plugboard = pbMatrix[pbIndex];

		LOG.debug("Enigma4K.pbCrypt(" + wordCode + ", " + pbIndex + "): pbIndex: " +
			(pbIndex % pbMatrix.length) + ", newWordCode: " + plugboard[wordCode]);
		
		return plugboard[wordCode];
	}
	
	/** Rotor encrypt/decrypt.				*/
	private int roCrypt(int wordCode) {
		
		LOG.info("Enigma4K.roCrypt(" + wordCode + ") START");
		
		int[] roOrder = rndOrder(RND);
		int roID = encrypt ? 0 : roMatrix.length - 1;

		do {
				
			int[] rotor = roMatrix[roOrder[roID]];
			wordCode = encrypt ?
				rotor[((roIndex[roID] + wordCode) % DIR_SIZE)] :
				((((rotor[wordCode] - roIndex[roID]) % DIR_SIZE) + DIR_SIZE) % DIR_SIZE);

			roID += encrypt ? 1 : -1;
		}
		while( (encrypt && roID < roMatrix.length) || (!encrypt && roID >= 0) );

		LOG.info("Enigma4K.roCrypt() STOP");
		stepRotors(roIndex);
		return wordCode;
	}
	
	/**
	 * Static decryption.
	 * 
	 * @param passPhrase pass phrase or password
	 * @param handle recipient email, handle, or name
	 * @param roCount rotor count
	 * @param pbCount plugboard count
	 * @param dirSeed directory randomization seed, default is null
	 * @param cryptText text message to encrypt
	 * @return plain text
	 * @throws Exception 
	 */
	public static String decryptText(String passPhrase, String handle,
		int roCount, int pbCount, Long dirSeed, String cryptText) throws Exception {
		
		LOG.info("Enigma4K.decryptText()");
		
		encrypt = false;
		
		String msgID = cryptText.substring(0, 9);
		cryptText = cryptText.substring(9, cryptText.length());
						
		Enigma4K enigma = new Enigma4K(passPhrase, handle, msgID, roCount, pbCount);
			enigma.randomizeDirectory(dirSeed);
		
		return enigma.decryptText(cryptText);
	}
	
	/**
	 * Decrypt crypt text.
	 * 
	 * @param cryptText
	 * @return plaint text
	 */
	private String decryptText(String cryptText) throws Exception {
		
		LOG.info("Enigma4K.decryptText()");
		
		encrypt = false;
		
		StringBuilder log;
		
		if(cryptText.length() % 3 != 0) {
			LOG.error("Encrypted text must be a multiple of three, cryptText: " + (cryptText.length() % 3));
			throw new Exception("cryptText incorrect length");
		}

		String[] cryptTextArr = cryptText.split("(?<=\\G.{3})");
		StringBuilder text = new StringBuilder();
		boolean wSpace = true;			// white space

		for(String wordCodeStr: cryptTextArr) {
			
			log = new StringBuilder();
			
				log.append("cryptText: ").append(wordCodeStr).append(", ");
			int wordCode = base36ToInt(wordCodeStr);
				log.append("base36ToInt: ").append(wordCode).append(", ");

			int index = RND.nextInt(pbMatrix.length);
			wordCode = pbCrypt(wordCode, index);
				log.append("pbD:").append(wordCode).append(", ");
			wordCode = roCrypt(wordCode);
				log.append("rD:").append(wordCode).append(", ");
			wordCode = pbCrypt(wordCode, index);
				log.append("pbD:").append(wordCode).append(", ");

			String word = directory.getWord(wordCode);
				word = word.replace("\\s,", ",");
				word = word.replace("\\s.", ".");
				log.append("direcWord: ").append(word);

			if(word.equals("<%"))	wSpace = false;
			if(word.equals("%>"))	wSpace = true;

			text.append(word.replace("<%", "").replace("%>", ""));
			if(wSpace)	text.append(" ");

			LOG.debug(log.toString());
		}

		LOG.info("Decrypt encrypted text.");
		
		return text.toString()
			.trim()
			.toUpperCase()
			.replaceAll("\\s{2,}", " ")			// replace multiple spaces
			.replaceAll(" :", ":")				// remove spaces before colon
			.replaceAll(" ;", ";")				// remove spaces before semicolon
			.replaceAll(" ,", ",")				// remove spaces before commas
			.replaceAll(" \\.", ".");			// remove spaces before period
	}
	
	/** Base 10 to Base 36.		*/
	private static String intToBase36(int base10) {
		return Integer.toString(base10, Character.MAX_RADIX);
	}
	
	/** Base 36 to Base 10.		*/
	private static int base36ToInt(String base36) {
		return Integer.parseInt(base36, Character.MAX_RADIX);
	}
	
	/** Base 10 to Base 36.		*/
	public static String longToBase36(long base10) {
		return Long.toString(base10, Character.MAX_RADIX);
	}

	/**
	 * Text to pad.
	 * 
	 * @param str string to pad
	 * @param length desired string length
	 * @return padded string
	 */
	private static String padText(String str, int length) {

		if((length - str.length()) > 0)		return padText("0" + str, length);
		return str;
	}
	
	/** String to long hash using SipHash 64bit.			*/
	private static long hashCode(String str) {

		// java long hashCode
//		long hash = 0;
//		
//		if(str.length() > 0) {
//			char val[] = str.toCharArray();
//			for(int i = 0; i < str.length(); i++)
//				hash = 31 * hash + val[i];
//		}
//
//		return hash;

		SipHash hasher = new SipHash(hashKey.getBytes());
		return hasher.hash(str.getBytes()).get();
	}
	
	private static int[] seqRotor;		// sequential rotor 0,1,2,3, ...
	
	/**
	 * Builds a random rotor or plugboard.
	 * 
	 * @return a new rotor
	 */
	private static int[] genRotorPb(long seed) {
		
		Random rnd = new Random(seed);

		if(seqRotor == null) {
			seqRotor = new int[Enigma4K.DIR_SIZE];			// 46655, ZZZ
			for(int i = 0; i < seqRotor.length; i++)		seqRotor[i] = i;
		}
		
		int[] arr = seqRotor.clone();
		Util.shuffle(rnd, arr);
		return arr;
	}
	
	/**
	 * Array inversion, index and value switch.
	 * 
	 * @param arr
	 * @return inverted array
	 */
	private static int[] invArr(int[] arr) {
		
		int[] invArr = new int[arr.length];
		
		for(int index = 0; index < arr.length; index++) {
			int val = arr[index];
			invArr[val] = index;
		}
		
		return invArr;
	}
	
	/**
	 * This method will randomize the directory based on the seed supplied.
	 * Randomizing the directory increases security however both parties must
	 * use the same seed when randomizing the directory to ensure that both
	 * parties have the same directory.
	 */
	public void randomizeDirectory(Long seed) {
		if(directory != null && seed != null)
			directory.randomizeDirectory(seed);
	}
	
	/** Memory usage.			*/
	private static void memory() {
		
		long MEGABYTE = 1024L * 1024L;

		Runtime runtime = Runtime.getRuntime();
		NumberFormat format = NumberFormat.getInstance();

		StringBuilder sb = new StringBuilder();
		long maxMemory = runtime.maxMemory();
		long allocatedMemory = runtime.totalMemory();
		long freeMemory = runtime.freeMemory();

		sb.append("free memory: ").append(format.format(freeMemory / MEGABYTE)).append("\n");
		sb.append("allocated memory: ").append(format.format(allocatedMemory / MEGABYTE)).append("\n");
		sb.append("max memory: ").append(format.format(maxMemory / MEGABYTE)).append("\n");
		sb.append("total free memory: ").append(format.format((freeMemory + (maxMemory - allocatedMemory)) / MEGABYTE)).append("\n");
		
		LOG.debug(sb.toString());
	}

//	/**
//	 * @param args the command line arguments
//	 */
//	public static void main(String[] args) {
//		
//		BasicConfigurator.configure();
//		Logger.getRootLogger().setLevel(Level.ERROR);
//		
//		String password = "password";
//		String handle = "handle";
//		
//		String[] textLine = new String[] {
//			"this is a test of the emergency broadcast system.",
//			"",
//			""
//		};
//
//		String[] repeat = new String[] {
//			"supercalifragilisticexpialidocious this zzzz didn't ` ~ ? : ; \" ' _ | / * - + = . , < > ! $ ( ) [ ] { } @ # % ^ &",
//			"",
//			""
//		};
//
//		try {
//			textLine[1] = Enigma4K.encryptText(password, handle, 103, 103, null, textLine[0]);
//			repeat[1] = Enigma4K.encryptText(password, handle, 103, 103, null, repeat[0]);
//		}
//		catch(Exception e) {
//			LOG.FATAL("Encrypt Error", e);
//		}
//
//		try {
//			textLine[2] = Enigma4K.decryptText(password, handle, 103, 103, null, textLine[1]);
//			repeat[2] = Enigma4K.decryptText(password, handle, 103, 103, null, repeat[1]);
//		}
//		catch(Exception ex) {
//			LOG.FATAL("Decrypt Text", ex);
//		}
//		
//		for(String line: textLine)	System.out.println(line);
//		for(String line: repeat)	System.out.println(line);
//	}
}

